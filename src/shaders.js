let roomVS = `in vec4 aVertexPosition;uniform mat4 uProjectionMatrix,uClipModelViewMatrix;out vec4 vViewVector;void main(){vec4 v=inverse(uProjectionMatrix)*vec4(aVertexPosition.xy,1.,1.);v/=v.w;vec4 n=inverse(uProjectionMatrix)*vec4(aVertexPosition.xy,-1.,1.);n/=n.w;vViewVector=v-n;gl_Position=uClipModelViewMatrix*vec4(aVertexPosition.xy,0.,1.);}`;
let roomFunctionsFS = `float sdfPlane(vec3 s,vec3 v){return dot(s,v);}float sdfBox(vec3 s,vec3 v){vec3 m=abs(s)-v;return length(max(m,0.))+min(max(m.x,max(m.y,m.z)),0.);}float sdfRoundedBox(vec3 s,vec3 v,float m){vec3 f=abs(s)-v;return length(max(f,0.))-m+min(max(f.x,max(f.y,f.z)),0.);}float sdfOpIntersection(float s,float v){return max(s,v);}float sdfOpExtrusion(vec3 s,float m,float v){vec2 f=vec2(m,abs(s.z)-v);return min(max(f.x,f.y),0.)+length(max(f,0.));}vec3 sdfOpRepeat(vec3 s,vec3 v){return mod(s,v)-.5*v;}float sdfOpSmoothUnion(float v,float s,float m){float f=clamp(.5+.5*(s-v)/m,0.,1.);return mix(s,v,f)-m*f*(1.-f);}const vec3 brickSize=vec3(.3,.13,.03);float sdfBrick4x4(vec3 s){const float v=.95;vec3 m=sdfOpRepeat(s,vec3(brickSize.xy*4.,0.));return sdfRoundedBox(m,brickSize*vec3(.8*v,.5*v,1.),.05);}float sdfBrickRow(vec3 s){return min(sdfBrick4x4(s),sdfBrick4x4(s-vec3(brickSize.x*2.,0.,0.)));}float sdfWall(vec3 s,vec2 v){float m=sdfPlane(s,vec3(0.,0.,1.)),f=min(sdfBrickRow(s),sdfBrickRow(s-vec3(brickSize.x,brickSize.y*2.,0.)));return sdfOpIntersection(min(m,f),sdfBox(s,vec3(v,brickSize.z*2.5)));}float sdfPlayerShip(vec3 s){return sdfOpSmoothUnion(sdfBox(s,vec3(.1,.1,.3)),sdfBox(s-vec3(0.,0.,.15),vec3(.4,.05,.1)),.1);}float dynamicStuff(vec3 s){return sdfPlayerShip(vec3(uDynamicTransforms[0]*vec4(s,1.)));}`;
let roomHeaderFS = `in vec4 vViewVector;uniform mat4 uModelViewMatrix;uniform ivec2 uScreenSize;uniform mat4 uDynamicTransforms[10];layout(location=0)out vec4 fragColor;`;
let roomRenderFS = `float shadow(vec3 v,vec3 s,float m,float x){float f=1.,e=m;for(int i=0;i<32;i++){float u=room(v+s*e).x;f=min(f,10.*u/e);e+=u;if(abs(u)<.001||e>x)break;}return step(.01,f);}vec3 shade(vec3 v,vec3 s,float u){if(u<.5)return vec3(.6);else if(u<1.5)return vec3(0.,0.,1.);return vec3(1.,0.,0.);}uniform mat4 uProjectionMatrix;void main(){const float v=3.;vec3 f=vec3(0.),u;vec2 i;float e=.1;mat4 s=inverse(uModelViewMatrix);vec2 m=gl_FragCoord.xy/vec2(uScreenSize);vec4 r=inverse(uProjectionMatrix)*vec4(m.xy*2.-vec2(1),-1.,1.),a=inverse(uProjectionMatrix)*vec4(m.xy*2.-vec2(1),1.,1.);vec3 x=r.xyz/r.w,y=normalize(a.xyz/a.w-x);for(int o=0;o<64;o++){u=x+y*e;u=vec3(s*vec4(u,1.));i=room(u);float n=i.x;if(abs(n)<.001||e>20.)break;e+=n;}if(e<20.){vec3 n=normalize(vec3(1.,1.,1.)),o=calcNormal(u);f=shade(u,o,i.y);float c=1.;c*=max(0.,dot(n,o));f*=min(1.,.4+c);}else{discard;}fragColor=vec4(f.xyz,1.);}`;
