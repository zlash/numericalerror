let roomVS = `attribute vec4 aVertexPosition;uniform mat4 uProjectionMatrix;varying vec2 vUvs;varying vec4 vViewVector;mat4 matInverse(mat4 v){return mat4(v[0][0],v[1][0],v[2][0],0.,v[0][1],v[1][1],v[2][1],0.,v[0][2],v[1][2],v[2][2],0.,-dot(v[0].xyz,v[3].xyz),-dot(v[1].xyz,v[3].xyz),-dot(v[2].xyz,v[3].xyz),1.);}void main(){vUvs=(aVertexPosition.xy+vec2(1.))*.5,vViewVector=matInverse(uProjectionMatrix)*vec4(aVertexPosition.xy,1.,1.),vViewVector/=vViewVector.w,gl_Position=vec4(aVertexPosition.xy,0.,1.);}`;
let roomFS = `varying vec2 vUvs;varying vec4 vViewVector;uniform mat4 uModelViewMatrix;float sdfPlane(vec3 m,vec3 v){return dot(m,v);}float sdfBox(vec3 m,vec3 s){vec3 v=abs(m)-s;return length(max(v,0.))+min(max(v.x,max(v.y,v.z)),0.);}float sdfRoundedBox(vec3 m,vec3 s,float v){vec3 f=abs(m)-s;return length(max(f,0.))-v+min(max(f.x,max(f.y,f.z)),0.);}float sdfOpIntersection(float m,float v){return max(m,v);}vec3 sdfOpRepeat(vec3 m,vec3 v){return mod(m,v)-.5*v;}float sdfOpSmoothUnion(float v,float m,float s){float f=clamp(.5+.5*(m-v)/s,0.,1.);return mix(m,v,f)-s*f*(1.-f);}const vec3 brickSize=vec3(.3,.13,.03);float sdfBrick4x4(vec3 m){const float v=.95;vec3 s=sdfOpRepeat(m,vec3(brickSize.xy*4.,0.));return sdfRoundedBox(s,brickSize*vec3(.8*v,.5*v,1.),.05);}float sdfBrickRow(vec3 m){return min(sdfBrick4x4(m),sdfBrick4x4(m-vec3(brickSize.x*2.,0.,0.)));}float sdfWall(vec3 m,vec2 v){float s=sdfPlane(m,vec3(0.,0.,1.)),f=min(sdfBrickRow(m),sdfBrickRow(m-vec3(brickSize.x,brickSize.y*2.,0.)));return sdfOpIntersection(min(s,f),sdfBox(m,vec3(v,.5)));}mat4 matInverse(mat4 v){return mat4(v[0][0],v[1][0],v[2][0],0.,v[0][1],v[1][1],v[2][1],0.,v[0][2],v[1][2],v[2][2],0.,-dot(v[0].xyz,v[3].xyz),-dot(v[1].xyz,v[3].xyz),-dot(v[2].xyz,v[3].xyz),1.);}vec2 room(vec3 m){float v=min(min(min(min(min(sdfWall(vec3(matInverse(mat4(1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,0.,0.,0.,-3.,1.))*vec4(m,1.)),vec2(3.,1.)),sdfWall(vec3(matInverse(mat4(.5547,0.,-.83205,0.,0.,1.,0.,0.,.83205,0.,.5547,0.,-4.,0.,-1.5,1.))*vec4(m,1.)),vec2(1.80278,1.))),sdfWall(vec3(matInverse(mat4(-.5547,0.,-.83205,0.,0.,1.,0.,0.,.83205,0.,-.5547,0.,-4.,0.,1.5,1.))*vec4(m,1.)),vec2(1.80278,1.))),sdfWall(vec3(matInverse(mat4(-1.,0.,1.22465e-16,0.,0.,1.,0.,0.,-1.22465e-16,0.,-1.,0.,0.,0.,3.,1.))*vec4(m,1.)),vec2(3.,1.))),sdfWall(vec3(matInverse(mat4(-.5547,0.,.83205,0.,0.,1.,0.,0.,-.83205,0.,-.5547,0.,4.,0.,1.5,1.))*vec4(m,1.)),vec2(1.80278,1.))),sdfWall(vec3(matInverse(mat4(.5547,0.,.83205,0.,0.,1.,0.,0.,-.83205,0.,.5547,0.,4.,0.,-1.5,1.))*vec4(m,1.)),vec2(1.80278,1.)));return vec2(v,-1.);}vec3 calcNormal(in vec3 m){const float v=.0001;vec2 s=vec2(1.,-1.)*.5773;return normalize(s.xyy*room(m+s.xyy*v).x+s.yyx*room(m+s.yyx*v).x+s.yxy*room(m+s.yxy*v).x+s.xxx*room(m+s.xxx*v).x);}float shadow(vec3 m,vec3 s,float v,float f){float z=1.,r=v;for(int i=0;i<32;i++){float x=room(m+s*r).x;z=min(z,10.*x/r);r+=x;if(abs(x)<.001||r>f)break;}return step(.01,z);}void main(){const float v=3.;vec3 m=vec3(0.),f;vec2 s;float r=.1;mat4 x=matInverse(uModelViewMatrix);vec3 y=normalize(vViewVector.xyz);for(int i=0;i<64;i++){f=y*r;f=vec3(x*vec4(f,1.));s=room(f);float z=s.x;if(abs(z)<.001||r>20.)break;r+=z;}if(r<20.){vec3 z=normalize(vec3(1.,1.,1.));if(s.y>0.)m=vec3(1.,0.,0.);else m=vec3(.6);vec3 i=calcNormal(f);float e=1.;e*=max(0.,dot(z,i));m*=min(1.,.4+e);}gl_FragColor=vec4(m.xyz,1.);}`;
let roomFunctionsFS = `float sdfPlane(vec3 s,vec3 v){return dot(s,v);}float sdfBox(vec3 s,vec3 v){vec3 m=abs(s)-v;return length(max(m,0.))+min(max(m.x,max(m.y,m.z)),0.);}float sdfRoundedBox(vec3 s,vec3 v,float m){vec3 f=abs(s)-v;return length(max(f,0.))-m+min(max(f.x,max(f.y,f.z)),0.);}float sdfOpIntersection(float s,float v){return max(s,v);}vec3 sdfOpRepeat(vec3 s,vec3 v){return mod(s,v)-.5*v;}float sdfOpSmoothUnion(float v,float s,float m){float f=clamp(.5+.5*(s-v)/m,0.,1.);return mix(s,v,f)-m*f*(1.-f);}const vec3 brickSize=vec3(.3,.13,.03);float sdfBrick4x4(vec3 s){const float v=.95;vec3 m=sdfOpRepeat(s,vec3(brickSize.xy*4.,0.));return sdfRoundedBox(m,brickSize*vec3(.8*v,.5*v,1.),.05);}float sdfBrickRow(vec3 s){return min(sdfBrick4x4(s),sdfBrick4x4(s-vec3(brickSize.x*2.,0.,0.)));}float sdfWall(vec3 s,vec2 v){float m=sdfPlane(s,vec3(0.,0.,1.)),f=min(sdfBrickRow(s),sdfBrickRow(s-vec3(brickSize.x,brickSize.y*2.,0.)));return sdfOpIntersection(min(m,f),sdfBox(s,vec3(v,brickSize.z*2.5)));}`;
let roomHeaderFS = `varying vec2 vUvs;varying vec4 vViewVector;uniform mat4 uModelViewMatrix;`;
let roomRenderFS = `vec3 calcNormal(in vec3 x){const float r=.0001;vec2 v=vec2(1.,-1.)*.5773;return normalize(v.xyy*room(x+v.xyy*r).x+v.yyx*room(x+v.yyx*r).x+v.yxy*room(x+v.yxy*r).x+v.xxx*room(x+v.xxx*r).x);}float shadow(vec3 x,vec3 v,float m,float r){float f=1.,i=m;for(int s=0;s<32;s++){float n=room(x+v*i).x;f=min(f,10.*n/i);i+=n;if(abs(n)<.001||i>r)break;}return step(.01,f);}void main(){const float f=3.;vec3 v=vec3(0.),x;vec2 m;float r=.1;mat4 i=matInverse(uModelViewMatrix);vec3 n=normalize(vViewVector.xyz);for(int s=0;s<64;s++){x=n*r;x=vec3(i*vec4(x,1.));m=room(x);float a=m.x;if(abs(a)<.001||r>20.)break;r+=a;}if(r<20.){vec3 s=normalize(vec3(1.,1.,1.));if(m.y>0.)v=vec3(1.,0.,0.);else v=vec3(.6);vec3 a=calcNormal(x);float y=1.;y*=max(0.,dot(s,a));v*=min(1.,.4+y);}gl_FragColor=vec4(v.xyz,1.);}`;
