<!DOCTYPE html><p><script>let n={};let t=0;function e(o){let r=n.t;o*=.001;t=o,r.clear(r.COLOR_BUFFER_BIT),r.bindBuffer(r.ARRAY_BUFFER,n.o),r.vertexAttribPointer(n.i,2,r.FLOAT,!1,0,0),r.enableVertexAttribArray(n.i),r.useProgram(n.l);let c=[0,0,3],m=function(n,t,e,o=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){let r=a(function(n,t,e=[0,0,0]){return e[0]=n[0]-t[0],e[1]=n[1]-t[1],e[2]=n[2]-t[2],e}(t,n)),c=a(l(r,e)),m=l(c,r);return o[0]=c[0],o[4]=c[1],o[8]=c[2],o[1]=m[0],o[5]=m[1],o[9]=m[2],o[2]=-r[0],o[6]=-r[1],o[10]=-r[2],o[12]=-i(c,n),o[13]=-i(m,n),o[14]=i(r,n),o}(c,function(n,t,e=[0,0,0]){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e}(c,[Math.sin(.4*o),Math.cos(.4*o),-1]),[0,1,0]);r.uniformMatrix4fv(n.m,!1,m),r.drawArrays(r.TRIANGLE_STRIP,0,4),requestAnimationFrame(e)}window.onload=function(){const t=document.createElement("canvas");let i=t.getContext("webgl");n.t=i,t.width=800,t.height=600,n.t.viewport(0,0,n.t.canvas.width,n.t.canvas.height),document.body.appendChild(t),i.clearColor(0,1,0,1);var a=function(n,t,e){const o=c(n,n.VERTEX_SHADER,t),r=c(n,n.FRAGMENT_SHADER,e),i=n.createProgram();n.attachShader(i,o),n.attachShader(i,r),n.linkProgram(i),!1;return i}(i,o,r);n.i=i.getAttribLocation(a,"aVertexPosition"),n.s=i.getUniformLocation(a,"uProjectionMatrix"),n.m=i.getUniformLocation(a,"uModelViewMatrix"),n.l=a,function(t){const e=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,1,-1,-1,1,1,1,-1]),t.STATIC_DRAW),n.o=e}(i),requestAnimationFrame(e)};const o="\n  attribute vec4 aVertexPosition;\n\n  uniform mat4 uProjectionMatrix;\n\n  varying vec2 vUvs;\n\n  void main() {\n    vUvs = (aVertexPosition.xy+vec2(1.0))*0.5;\n    gl_Position = vec4(aVertexPosition.xy,0.0,1.0);\n  }\n",r="\nprecision highp float;\nvarying vec2 vUvs;\n\nuniform mat4 uModelViewMatrix;\n\nfloat sdfPlane(vec3 pos, vec3 n)\n{\n    return dot(pos,n);\n}\n\nfloat sdfWall(vec3 pos) {\n    return sdfPlane(pos, n);\n}\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    float r =0.1;\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdBoxes( vec3 p, vec3 b )\n{\n    vec3 c =vec3(1.6,1.6,0.0);\n    vec3 q = mod(p,c)-0.5*c;\n    return sdBox(q,b);\n}\n\nvec2 room(vec3 pos)\n{\n    /*float d = 1e10;\n    d = min(d,sdBoxes(pos,vec3(0.5,0.3,0.2)));\n\n    float pl= plane(pos);\n    if(d<pl) {\n        return vec2(d,1.0);\n    }*/\n\n    return vec2(sdfWall(pos),-1.0);\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*room( pos + e.xyy*ep ).x + \n\t\t\t\t\t  e.yyx*room( pos + e.yyx*ep ).x + \n\t\t\t\t\t  e.yxy*room( pos + e.yxy*ep ).x + \n\t\t\t\t\t  e.xxx*room( pos + e.xxx*ep ).x );\n}\n\n\n\nmat4 matInverse( mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\n\nfloat shadow( vec3 ro,  vec3 rd, float mint,  float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = room( ro + rd*t ).x;\n\n        res = min( res, 10.0*h/t );\n\n        t += h;\n        \n        if( abs(h)<0.001 || t>tmax ) break;\n        \n    }\n    return step( 0.01, res );\n}\n\n\nvoid main() {\n    const float sensorSize = 3.0;\n    vec3 col = vec3(0.0);\n    vec3 p;\n    vec2 mt;\n    float t = 0.1;\n    mat4 invModelView = matInverse(uModelViewMatrix);\n    for( int i=0; i<64; i++ )\n    {\n        p = vec3(sensorSize*(vUvs*2.0-1.0),0.0)+vec3(0.0,0.0,-1.0)*t;\n        p = vec3(invModelView * vec4(p,1.0));\n        mt = room(p);\n        float h = mt.x;\n        if( abs(h)<0.001 || t>20.0 ) break;\n        t += h;\n    }\n\n    if( t<20.0 )\n    {   vec3 light = normalize(vec3(1.0,1.0,1.0));\n        if(mt.y>0.0) {\n            col = vec3(0.8,0.0,0.0);\n        }else{\n        col = vec3(1.0);\n        }\n        vec3 n = calcNormal(p);\n\n        col*=dot(light,n);\n        col*=shadow(p,light,0.05,20.0);\n    }\n\n    gl_FragColor = vec4(col.xyz, 1.0);\n}\n";function c(n,t,e){const o=n.createShader(t);return n.shaderSource(o,e),n.compileShader(o),o}function i(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function a(n,t=[0,0,0]){let e=function(n){return Math.sqrt(i(n,n))}(n);return t[0]=n[0]/e,t[1]=n[1]/e,t[2]=n[2]/e,t}function l(n,t,e=[0,0,0]){return e[0]=n[1]*t[2]-n[2]*t[1],e[1]=n[2]*t[0]-n[0]*t[2],e[2]=n[0]*t[1]-n[1]*t[0],e}</script>
