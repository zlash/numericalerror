<!DOCTYPE html><head><title>Debug</title></head><p><script>let n={};let t=0;function e(o){let r=n.t;o*=.001;t=o,r.clear(r.COLOR_BUFFER_BIT),r.bindBuffer(r.ARRAY_BUFFER,n.o),r.vertexAttribPointer(n.i,2,r.FLOAT,!1,0,0),r.enableVertexAttribArray(n.i),r.useProgram(n.l);let i=[0,0,3],s=function(n,t,e,o=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){let r=c(function(n,t,e=[0,0,0]){return e[0]=n[0]-t[0],e[1]=n[1]-t[1],e[2]=n[2]-t[2],e}(t,n)),i=c(l(r,e)),s=l(i,r);return o[0]=i[0],o[4]=i[1],o[8]=i[2],o[1]=s[0],o[5]=s[1],o[9]=s[2],o[2]=-r[0],o[6]=-r[1],o[10]=-r[2],o[12]=-a(i,n),o[13]=-a(s,n),o[14]=a(r,n),o}(i,function(n,t,e=[0,0,0]){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e}(i,[Math.sin(.4*o),Math.cos(.4*o),-1]),[0,1,0]);r.uniformMatrix4fv(n.s,!1,s),r.drawArrays(r.TRIANGLE_STRIP,0,4),requestAnimationFrame(e)}window.onload=function(){console.log("js12k2019 - Debug mode [ON]");const t=document.createElement("canvas");let a=t.getContext("webgl");n.t=a,t.width=800,t.height=600,n.t.viewport(0,0,n.t.canvas.width,n.t.canvas.height),document.body.appendChild(t),a.clearColor(0,1,0,1);var c=function(n,t,e){const o=i(n,n.VERTEX_SHADER,t),r=i(n,n.FRAGMENT_SHADER,e),a=n.createProgram();if(n.attachShader(a,o),n.attachShader(a,r),n.linkProgram(a),!n.getProgramParameter(a,n.LINK_STATUS))return alert("Unable to initialize the shader program: "+n.getProgramInfoLog(a)),null;return a}(a,o,r);n.i=a.getAttribLocation(c,"aVertexPosition"),n.m=a.getUniformLocation(c,"uProjectionMatrix"),n.s=a.getUniformLocation(c,"uModelViewMatrix"),n.l=c,function(t){const e=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,1,-1,-1,1,1,1,-1]),t.STATIC_DRAW),n.o=e}(a),requestAnimationFrame(e)};const o="\n  attribute vec4 aVertexPosition;\n\n  uniform mat4 uProjectionMatrix;\n\n  varying vec2 vUvs;\n\n  void main() {\n    vUvs = (aVertexPosition.xy+vec2(1.0))*0.5;\n    gl_Position = vec4(aVertexPosition.xy,0.0,1.0);\n  }\n",r="\nprecision highp float;\nvarying vec2 vUvs;\n\nuniform mat4 uModelViewMatrix;\n\nfloat sdfPlane(vec3 pos, vec3 n)\n{\n    return dot(pos,n);\n}\n\nfloat sdfWall(vec3 pos) {\n    return sdfPlane(pos, n);\n}\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    float r =0.1;\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdBoxes( vec3 p, vec3 b )\n{\n    vec3 c =vec3(1.6,1.6,0.0);\n    vec3 q = mod(p,c)-0.5*c;\n    return sdBox(q,b);\n}\n\nvec2 room(vec3 pos)\n{\n    /*float d = 1e10;\n    d = min(d,sdBoxes(pos,vec3(0.5,0.3,0.2)));\n\n    float pl= plane(pos);\n    if(d<pl) {\n        return vec2(d,1.0);\n    }*/\n\n    return vec2(sdfWall(pos),-1.0);\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*room( pos + e.xyy*ep ).x + \n\t\t\t\t\t  e.yyx*room( pos + e.yyx*ep ).x + \n\t\t\t\t\t  e.yxy*room( pos + e.yxy*ep ).x + \n\t\t\t\t\t  e.xxx*room( pos + e.xxx*ep ).x );\n}\n\n\n\nmat4 matInverse( mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\n\nfloat shadow( vec3 ro,  vec3 rd, float mint,  float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = room( ro + rd*t ).x;\n\n        res = min( res, 10.0*h/t );\n\n        t += h;\n        \n        if( abs(h)<0.001 || t>tmax ) break;\n        \n    }\n    return step( 0.01, res );\n}\n\n\nvoid main() {\n    const float sensorSize = 3.0;\n    vec3 col = vec3(0.0);\n    vec3 p;\n    vec2 mt;\n    float t = 0.1;\n    mat4 invModelView = matInverse(uModelViewMatrix);\n    for( int i=0; i<64; i++ )\n    {\n        p = vec3(sensorSize*(vUvs*2.0-1.0),0.0)+vec3(0.0,0.0,-1.0)*t;\n        p = vec3(invModelView * vec4(p,1.0));\n        mt = room(p);\n        float h = mt.x;\n        if( abs(h)<0.001 || t>20.0 ) break;\n        t += h;\n    }\n\n    if( t<20.0 )\n    {   vec3 light = normalize(vec3(1.0,1.0,1.0));\n        if(mt.y>0.0) {\n            col = vec3(0.8,0.0,0.0);\n        }else{\n        col = vec3(1.0);\n        }\n        vec3 n = calcNormal(p);\n\n        col*=dot(light,n);\n        col*=shadow(p,light,0.05,20.0);\n    }\n\n    gl_FragColor = vec4(col.xyz, 1.0);\n}\n";function i(n,t,e){const o=n.createShader(t);return n.shaderSource(o,e),n.compileShader(o),n.getShaderParameter(o,n.COMPILE_STATUS)?o:(alert("An error occurred compiling the shaders: "+n.getShaderInfoLog(o)),n.deleteShader(o),null)}function a(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function c(n,t=[0,0,0]){let e=function(n){return Math.sqrt(a(n,n))}(n);return t[0]=n[0]/e,t[1]=n[1]/e,t[2]=n[2]/e,t}function l(n,t,e=[0,0,0]){return e[0]=n[1]*t[2]-n[2]*t[1],e[1]=n[2]*t[0]-n[0]*t[2],e[2]=n[0]*t[1]-n[1]*t[0],e}</script>
