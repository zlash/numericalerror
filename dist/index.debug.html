<!DOCTYPE html><head><title>Debug</title></head><p><script>let n={};let t=0,e=[0,0,3],o=[0,0,-1];function r(c){let i=n.t;const a=(c*=.001)-t;if(t=c,i.clear(i.COLOR_BUFFER_BIT),i.bindBuffer(i.ARRAY_BUFFER,n.o),i.vertexAttribPointer(n.i,2,i.FLOAT,!1,0,0),i.enableVertexAttribArray(n.i),i.useProgram(n.s),v=k,p=b,k=0,b=0,0!=v){let n=function(n,t,e=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){const o=Math.cos(t),r=Math.sin(t),c=1-o;return e[0]=o+n[0]*n[0]*c,e[1]=n[0]*n[1]*c+n[2]*r,e[2]=n[0]*n[2]*c-n[1]*r,e[4]=n[0]*n[1]*c-n[2]*r,e[5]=o+n[1]*n[1]*c,e[6]=n[1]*n[2]*c+n[0]*r,e[8]=n[0]*n[2]*c+n[1]*r,e[9]=n[1]*n[2]*c-n[0]*r,e[10]=o+n[2]*n[2]*c,e}([0,1,0],a*-v);o=d(o=function(n,t,e,o=[0,0,0]){let r=[...t,e];for(let t=0;t<3;t++){o[t]=0;for(let e=0;e<4;e++)o[t]+=n[4*e+t]*r[e]}return o}(n,o,0))}B(y)&&(e=s(e,m(o,a),e)),B(h)&&(e=l(e,m(o,a),e));let x=function(n,t,e,o=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){let r=d(l(t,n)),c=d(u(r,e)),i=u(c,r);return o[0]=c[0],o[4]=c[1],o[8]=c[2],o[1]=i[0],o[5]=i[1],o[9]=i[2],o[2]=-r[0],o[6]=-r[1],o[10]=-r[2],o[12]=-f(c,n),o[13]=-f(i,n),o[14]=f(r,n),o}(e,s(e,o),[0,1,0]);i.uniformMatrix4fv(n.l,!1,x),i.drawArrays(i.TRIANGLE_STRIP,0,4),requestAnimationFrame(r)}window.onload=function(){console.log("js12k2019 - Debug mode [ON]");const t=document.createElement("canvas");let e=t.getContext("webgl");n.t=e,t.width=800,t.height=600,n.t.viewport(0,0,n.t.canvas.width,n.t.canvas.height),document.body.appendChild(t),e.clearColor(0,1,0,1);var o=function(n,t,e){const o=a(n,n.VERTEX_SHADER,t),r=a(n,n.FRAGMENT_SHADER,e),c=n.createProgram();if(n.attachShader(c,o),n.attachShader(c,r),n.linkProgram(c),!n.getProgramParameter(c,n.LINK_STATUS))return alert("Unable to initialize the shader program: "+n.getProgramInfoLog(c)),null;return c}(e,c,i);n.i=e.getAttribLocation(o,"aVertexPosition"),n.m=e.getUniformLocation(o,"uProjectionMatrix"),n.l=e.getUniformLocation(o,"uModelViewMatrix"),n.s=o,function(t){const e=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,1,-1,-1,1,1,1,-1]),t.STATIC_DRAW),n.o=e}(e),document.body.addEventListener("keydown",z,!1),document.body.addEventListener("keyup",g,!1),document.addEventListener("pointerlockchange",M,!1),document.addEventListener("mozpointerlockchange",M,!1),t.addEventListener("click",()=>(function(){let t=n.t.canvas;t.requestPointerLock=t.requestPointerLock||t.mozRequestPointerLock,t.requestPointerLock()})(),!1),requestAnimationFrame(r)};const c="\n  attribute vec4 aVertexPosition;\n\n  uniform mat4 uProjectionMatrix;\n\n  varying vec2 vUvs;\n\n  void main() {\n    vUvs = (aVertexPosition.xy+vec2(1.0))*0.5;\n    gl_Position = vec4(aVertexPosition.xy,0.0,1.0);\n  }\n",i="\nprecision highp float;\nvarying vec2 vUvs;\n\nuniform mat4 uModelViewMatrix;\n\nfloat sdfPlane(vec3 pos, vec3 n)\n{\n    return dot(pos,n);\n}\n\nfloat sdfBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdfRoundedBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdfOpIntersection( float d1, float d2 ) {\n     return max(d1,d2); \n}\n\n//Apply before primitive\nvec3 sdfOpRepeat(vec3 p,vec3 c)\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat sdfOpSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nconst vec3 brickSize = vec3(0.3,0.13,0.03);\n\nfloat sdfBrick4x4(vec3 pos) {\n    const float separation=0.95;\n    vec3 repeat = sdfOpRepeat(pos,vec3(brickSize.xy*4.0,0.0));\n    return sdfRoundedBox(repeat, brickSize*vec3(0.8*separation,0.5*separation,1.0),0.05);\n}\n\nfloat sdfBrickRow(vec3 pos) {\n    return min(sdfBrick4x4(pos),sdfBrick4x4(pos-vec3(brickSize.x*2.0,0.0,0.0)));\n}\n\nfloat sdfWall(vec3 pos) {\n\n    float d = sdfPlane(pos, vec3(0.0,0.0,1.0));\n\n    float bricksD = min(sdfBrickRow(pos),sdfBrickRow(pos-vec3(brickSize.x,brickSize.y*2.0,0.0)));\n\n    return sdfOpIntersection(sdfOpSmoothUnion(d,bricksD,0.05),sdfBox(pos,vec3(1.0,1.0,1.0)));\n}\n\n\n/*\nfloat sdBoxes( vec3 p, vec3 b )\n{\n    vec3 c =vec3(1.6,1.6,0.0);\n    vec3 q = mod(p,c)-0.5*c;\n    return sdBox(q,b);\n}*/\n\nvec2 room(vec3 pos)\n{\n    return vec2(sdfWall(pos),-1.0);\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*room( pos + e.xyy*ep ).x + \n\t\t\t\t\t  e.yyx*room( pos + e.yyx*ep ).x + \n\t\t\t\t\t  e.yxy*room( pos + e.yxy*ep ).x + \n\t\t\t\t\t  e.xxx*room( pos + e.xxx*ep ).x );\n}\n\n\n\nmat4 matInverse( mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\n\nfloat shadow( vec3 ro,  vec3 rd, float mint,  float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = room( ro + rd*t ).x;\n\n        res = min( res, 10.0*h/t );\n\n        t += h;\n        \n        if( abs(h)<0.001 || t>tmax ) break;\n        \n    }\n    return step( 0.01, res );\n}\n\n\nvoid main() {\n    const float sensorSize = 3.0;\n    vec3 col = vec3(0.0);\n    vec3 p;\n    vec2 mt;\n    float t = 0.1;\n    mat4 invModelView = matInverse(uModelViewMatrix);\n    for( int i=0; i<64; i++ )\n    {\n        p = vec3(sensorSize*(vUvs*2.0-1.0),0.0)+vec3(0.0,0.0,-1.0)*t;\n        p = vec3(invModelView * vec4(p,1.0));\n        mt = room(p);\n        float h = mt.x;\n        if( abs(h)<0.001 || t>20.0 ) break;\n        t += h;\n    }\n\n    if( t<20.0 )\n    {   vec3 light = normalize(vec3(1.0,1.0,1.0));\n        if(mt.y>0.0) {\n            col = vec3(1.0,0.0,0.0);\n        }else{\n        col = vec3(0.6);\n        }\n        vec3 n = calcNormal(p);\n\n        float att = 1.0;\n        att*=max(0.0,dot(light,n));\n        att*=shadow(p,light,0.05,20.0);\n        col*=min(1.0,0.4+att);\n    }\n\n    gl_FragColor = vec4(col.xyz, 1.0);\n}\n";function a(n,t,e){const o=n.createShader(t);return n.shaderSource(o,e),n.compileShader(o),n.getShaderParameter(o,n.COMPILE_STATUS)?o:(alert("An error occurred compiling the shaders: "+n.getShaderInfoLog(o)),n.deleteShader(o),null)}function s(n,t,e=[0,0,0]){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e}function l(n,t,e=[0,0,0]){return e[0]=n[0]-t[0],e[1]=n[1]-t[1],e[2]=n[2]-t[2],e}function m(n,t,e=[0,0,0]){return e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t,e}function f(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function d(n,t=[0,0,0]){let e=function(n){return Math.sqrt(f(n,n))}(n);return t[0]=n[0]/e,t[1]=n[1]/e,t[2]=n[2]/e,t}function u(n,t,e=[0,0,0]){return e[0]=n[1]*t[2]-n[2]*t[1],e[1]=n[2]*t[0]-n[0]*t[2],e[2]=n[0]*t[1]-n[1]*t[0],e}let v,p,x={},y="KeyW",h="KeyS",k=0,b=0;function z(n){x[n.code]=!0}function g(n){x[n.code]=!1}function w(n){n.movementX&&(k+=n.movementX),n.movementY&&(b+=n.movementY)}function M(){document.pointerLockElement===n.t.canvas||document.mozPointerLockElement===n.t.canvas?(console.log("Pointer Lock On"),document.addEventListener("mousemove",w,!1)):(console.log("Pointer Lock Off"),document.removeEventListener("mousemove",w,!1))}function B(n){return!!x[n]}</script>
