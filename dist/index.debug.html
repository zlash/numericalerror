<!DOCTYPE html><head><title>Debug</title></head><p><script>let n={};let e=0;function o(t){let i=n.o;t*=.001;e=t,i.clear(i.COLOR_BUFFER_BIT),i.bindBuffer(i.ARRAY_BUFFER,n.t),i.vertexAttribPointer(n.i,2,i.FLOAT,!1,0,0),i.enableVertexAttribArray(n.i),i.useProgram(n.l);let r=function(n,e,o=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){const t=Math.cos(e),i=Math.sin(e),r=1-t;return o[0]=t+n[0]*n[0]*r,o[1]=n[0]*n[1]*r+n[2]*i,o[2]=n[0]*n[2]*r-n[1]*i,o[4]=n[0]*n[1]*r-n[2]*i,o[5]=t+n[1]*n[1]*r,o[6]=n[1]*n[2]*r+n[0]*i,o[8]=n[0]*n[2]*r+n[1]*i,o[9]=n[1]*n[2]*r-n[0]*i,o[10]=t+n[2]*n[2]*r,o}([0,0,1],t);i.uniformMatrix4fv(n.s,!1,r),i.drawArrays(i.TRIANGLE_STRIP,0,4),requestAnimationFrame(o)}window.onload=function(){console.log("js12k2019 - Debug mode [ON]");const e=document.createElement("canvas");let a=e.getContext("webgl");n.o=a,e.width=800,e.height=600,n.o.viewport(0,0,n.o.canvas.width,n.o.canvas.height),document.body.appendChild(e),a.clearColor(0,1,0,1);var c=function(n,e,o){const t=r(n,n.VERTEX_SHADER,e),i=r(n,n.FRAGMENT_SHADER,o),a=n.createProgram();if(n.attachShader(a,t),n.attachShader(a,i),n.linkProgram(a),!n.getProgramParameter(a,n.LINK_STATUS))return alert("Unable to initialize the shader program: "+n.getProgramInfoLog(a)),null;return a}(a,t,i);n.i=a.getAttribLocation(c,"aVertexPosition"),n.v=a.getUniformLocation(c,"uProjectionMatrix"),n.s=a.getUniformLocation(c,"uModelViewMatrix"),n.l=c,function(e){const o=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,o),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,1,-1,-1,1,1,1,-1]),e.STATIC_DRAW),n.t=o}(a),requestAnimationFrame(o)};const t="\n  attribute vec4 aVertexPosition;\n\n  uniform mat4 uModelViewMatrix;\n  uniform mat4 uProjectionMatrix;\n\n  varying vec2 vUvs;\n\n  void main() {\n    vUvs = (aVertexPosition.xy+vec2(1.0))*0.5;\n    gl_Position = vec4(aVertexPosition.xy,0.0,1.0);\n  }\n",i="\nprecision mediump float;\nvarying vec2 vUvs;\n\nuniform mat4 uModelViewMatrix;\n\nfloat plane(vec3 pos)\n{\n    return dot(pos,vec3(0.0,0.0,1.0))-5.0;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat room(vec3 pos)\n{\n    float d = 1e10;\n    return min(d,sdBox(pos,vec3(0.5)));\n}\n\nvoid main() {\n    const float sensorSize = 3.0;\n    vec3 col = vec3(0.0);\n    float t = 0.1;\n    mat4 invModelView = inverse(uModelViewMatrix);\n    for( int i=0; i<64; i++ )\n    {\n        vec3 p = vec3(sensorSize*(vUvs*2.0-1.0),0.0)+vec3(0.0,0.0,-1.0)*t;\n        float h = room(vec3(invModelView*vec4(p,1.0)));\n        if( abs(h)<0.001 || t>10.0 ) break;\n        t += h;\n    }\n\n    if( t<10.0 )\n    {\n        col = vec3(0.5);\n    }\n\n    gl_FragColor = vec4(col.xyz, 1.0);\n}\n";function r(n,e,o){const t=n.createShader(e);return n.shaderSource(t,o),n.compileShader(t),n.getShaderParameter(t,n.COMPILE_STATUS)?t:(alert("An error occurred compiling the shaders: "+n.getShaderInfoLog(t)),n.deleteShader(t),null)}</script>
