<!DOCTYPE html><head><title>Debug</title></head><p><script>let n={};let t=0;function e(o){let r=n.t;o*=.001;t=o,r.clear(r.COLOR_BUFFER_BIT),r.bindBuffer(r.ARRAY_BUFFER,n.o),r.vertexAttribPointer(n.i,2,r.FLOAT,!1,0,0),r.enableVertexAttribArray(n.i),r.useProgram(n.s);let c=[0,0,3],l=function(n,t,e,o=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]){let r=a(function(n,t,e=[0,0,0]){return e[0]=n[0]-t[0],e[1]=n[1]-t[1],e[2]=n[2]-t[2],e}(t,n)),c=a(s(r,e)),l=s(c,r);return o[0]=c[0],o[4]=c[1],o[8]=c[2],o[1]=l[0],o[5]=l[1],o[9]=l[2],o[2]=-r[0],o[6]=-r[1],o[10]=-r[2],o[12]=-i(c,n),o[13]=-i(l,n),o[14]=i(r,n),o}(c,function(n,t,e=[0,0,0]){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e}(c,[Math.sin(.4*o),Math.cos(.4*o),-1]),[0,1,0]);r.uniformMatrix4fv(n.l,!1,l),r.drawArrays(r.TRIANGLE_STRIP,0,4),requestAnimationFrame(e)}window.onload=function(){console.log("js12k2019 - Debug mode [ON]");const t=document.createElement("canvas");let i=t.getContext("webgl");n.t=i,t.width=800,t.height=600,n.t.viewport(0,0,n.t.canvas.width,n.t.canvas.height),document.body.appendChild(t),i.clearColor(0,1,0,1);var a=function(n,t,e){const o=c(n,n.VERTEX_SHADER,t),r=c(n,n.FRAGMENT_SHADER,e),i=n.createProgram();if(n.attachShader(i,o),n.attachShader(i,r),n.linkProgram(i),!n.getProgramParameter(i,n.LINK_STATUS))return alert("Unable to initialize the shader program: "+n.getProgramInfoLog(i)),null;return i}(i,o,r);n.i=i.getAttribLocation(a,"aVertexPosition"),n.m=i.getUniformLocation(a,"uProjectionMatrix"),n.l=i.getUniformLocation(a,"uModelViewMatrix"),n.s=a,function(t){const e=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,1,-1,-1,1,1,1,-1]),t.STATIC_DRAW),n.o=e}(i),requestAnimationFrame(e)};const o="\n  attribute vec4 aVertexPosition;\n\n  uniform mat4 uProjectionMatrix;\n\n  varying vec2 vUvs;\n\n  void main() {\n    vUvs = (aVertexPosition.xy+vec2(1.0))*0.5;\n    gl_Position = vec4(aVertexPosition.xy,0.0,1.0);\n  }\n",r="\nprecision highp float;\nvarying vec2 vUvs;\n\nuniform mat4 uModelViewMatrix;\n\nfloat sdfPlane(vec3 pos, vec3 n)\n{\n    return dot(pos,n);\n}\n\nfloat sdfBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdfRoundedBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdfOpIntersection( float d1, float d2 ) {\n     return max(d1,d2); \n}\n\n//Apply before primitive\nvec3 sdfOpRepeat(vec3 p,vec3 c)\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat sdfOpSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nconst vec3 brickSize = vec3(0.3,0.13,0.03);\n\nfloat sdfBrick4x4(vec3 pos) {\n    const float separation=0.95;\n    vec3 repeat = sdfOpRepeat(pos,vec3(brickSize.xy*4.0,0.0));\n    return sdfRoundedBox(repeat, brickSize*vec3(0.8*separation,0.5*separation,1.0),0.05);\n}\n\nfloat sdfBrickRow(vec3 pos) {\n    return min(sdfBrick4x4(pos),sdfBrick4x4(pos-vec3(brickSize.x*2.0,0.0,0.0)));\n}\n\nfloat sdfWall(vec3 pos) {\n\n    float d = sdfPlane(pos, vec3(0.0,0.0,1.0));\n\n    float bricksD = min(sdfBrickRow(pos),sdfBrickRow(pos-vec3(brickSize.x,brickSize.y*2.0,0.0)));\n\n    return sdfOpIntersection(sdfOpSmoothUnion(d,bricksD,0.05),sdfBox(pos,vec3(1.0,1.0,1.0)));\n}\n\n\n/*\nfloat sdBoxes( vec3 p, vec3 b )\n{\n    vec3 c =vec3(1.6,1.6,0.0);\n    vec3 q = mod(p,c)-0.5*c;\n    return sdBox(q,b);\n}*/\n\nvec2 room(vec3 pos)\n{\n    return vec2(sdfWall(pos),-1.0);\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*room( pos + e.xyy*ep ).x + \n\t\t\t\t\t  e.yyx*room( pos + e.yyx*ep ).x + \n\t\t\t\t\t  e.yxy*room( pos + e.yxy*ep ).x + \n\t\t\t\t\t  e.xxx*room( pos + e.xxx*ep ).x );\n}\n\n\n\nmat4 matInverse( mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\n\nfloat shadow( vec3 ro,  vec3 rd, float mint,  float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = room( ro + rd*t ).x;\n\n        res = min( res, 10.0*h/t );\n\n        t += h;\n        \n        if( abs(h)<0.001 || t>tmax ) break;\n        \n    }\n    return step( 0.01, res );\n}\n\n\nvoid main() {\n    const float sensorSize = 3.0;\n    vec3 col = vec3(0.0);\n    vec3 p;\n    vec2 mt;\n    float t = 0.1;\n    mat4 invModelView = matInverse(uModelViewMatrix);\n    for( int i=0; i<64; i++ )\n    {\n        p = vec3(sensorSize*(vUvs*2.0-1.0),0.0)+vec3(0.0,0.0,-1.0)*t;\n        p = vec3(invModelView * vec4(p,1.0));\n        mt = room(p);\n        float h = mt.x;\n        if( abs(h)<0.001 || t>20.0 ) break;\n        t += h;\n    }\n\n    if( t<20.0 )\n    {   vec3 light = normalize(vec3(1.0,1.0,1.0));\n        if(mt.y>0.0) {\n            col = vec3(1.0,0.0,0.0);\n        }else{\n        col = vec3(0.6);\n        }\n        vec3 n = calcNormal(p);\n\n        float att = 1.0;\n        att*=max(0.0,dot(light,n));\n        att*=shadow(p,light,0.05,20.0);\n        col*=min(1.0,0.4+att);\n    }\n\n    gl_FragColor = vec4(col.xyz, 1.0);\n}\n";function c(n,t,e){const o=n.createShader(t);return n.shaderSource(o,e),n.compileShader(o),n.getShaderParameter(o,n.COMPILE_STATUS)?o:(alert("An error occurred compiling the shaders: "+n.getShaderInfoLog(o)),n.deleteShader(o),null)}function i(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function a(n,t=[0,0,0]){let e=function(n){return Math.sqrt(i(n,n))}(n);return t[0]=n[0]/e,t[1]=n[1]/e,t[2]=n[2]/e,t}function s(n,t,e=[0,0,0]){return e[0]=n[1]*t[2]-n[2]*t[1],e[1]=n[2]*t[0]-n[0]*t[2],e[2]=n[0]*t[1]-n[1]*t[0],e}</script>
